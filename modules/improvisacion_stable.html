<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>YsiSax - Improvisaci√≥n Blues</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/game.css">

    <!-- Libraries -->
    <script src="https://unpkg.com/vexflow@4.2.2/releases/vexflow-debug.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tonal/browser/tonal.min.js"></script>

    <!-- Core Scripts -->
    <script src="../js/midi-core.js"></script>
    <script src="../js/settings.js"></script>
</head>

<body>

    <button class="back-btn" onclick="window.location.href='../index.html'">‚Üê Volver</button>

    <h1 style="font-size: 2em; margin-top: 20px; margin-bottom: 20px;">Generador de Solos Blues & Jazz</h1>

    <div id="game-ui" style="display:flex; flex-direction:column; align-items:center;">

        <!-- CONTROLS -->
        <div class="controls" style="margin-bottom: 20px;">
            <div class="control-group">
                <label>Tonalidad (Concierto):</label>
                <select id="key-select">
                    <option value="C">C (Do)</option>
                    <option value="Db">Db (Reb)</option>
                    <option value="D">D (Re)</option>
                    <option value="Eb">Eb (Mib)</option>
                    <option value="E">E (Mi)</option>
                    <option value="F">F (Fa)</option>
                    <option value="Gb">Gb (Solb)</option>
                    <option value="G">G (Sol)</option>
                    <option value="Ab">Ab (Lab)</option>
                    <option value="A">A (La)</option>
                    <option value="Bb">Bb (Sib)</option>
                    <option value="B">B (Si)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Estilo:</label>
                <select id="style-select">
                    <option value="trad">Blues (M√°s silencios)</option>
                    <option value="jazz">Jazz (M√°s notas)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Dificultad (1-5):</label>
                <input type="range" id="diff-slider" min="1" max="5" value="2" style="width:100px;">
                <span id="diff-val">2</span>
            </div>

            <div class="control-group">
                <label>BPM:</label>
                <input type="number" id="bpm-input" value="100" min="60" max="200" style="width:60px;">
            </div>

            <button id="gen-btn" class="toggle-btn active">üé≤ GENERAR SOLO</button>
            <button id="metro-btn" class="toggle-btn">Metronomo OFF</button>
            <button id="play-btn" class="toggle-btn" style="border-color: #2cb613;">‚ñ∂ REPRODUCIR</button>
        </div>

        <!-- SCORE CONTAINER -->
        <!-- Fixed height for 3 rows of music -->
        <div id="music-container" style="height: 600px; display:block; padding: 20px;">
            <div id="cursor-line"></div>
            <div id="notation-output"></div>
        </div>
    </div>

    <!-- AUDIO & LOGIC -->
    <script>
        // --- CONFIG ---
        const VF = Vex.Flow;
        const CANVAS_WIDTH = 1200; // Increased for better spacing
        const CANVAS_HEIGHT = 600; // 3 Systems
        const ROW_HEIGHT = 180;

        // --- STATE ---
        let generatedScore = []; // Array of 12 Bars [ { notes: [], chord: "C7" } ]
        let isPlaying = false;
        let playbackEventId = null;
        let metroVol = null;

        // --- CLASSES ---

        class BluesGenerator {
            constructor() {
                this.rules = {
                    1: "Motif Start",
                    2: "Rest/Fill",
                    3: "Motif Variation",
                    4: "Tension End",
                    5: "IV Start",
                    6: "Low Density",
                    7: "Descending Line",
                    8: "Rest/Turn",
                    9: "Peak High",
                    10: "Med-High",
                    11: "Tonic Start",
                    12: "Turnaround V"
                };
            }

            generate(key, style, difficulty) {
                const scaleName = key + " minor blues";
                const scale = Tonal.Scale.get(scaleName).notes; // [C, Eb, F, Gb, G, Bb]
                const tonic = key + "4"; // Base octave 4

                // Expand Scale Range (Bb3 to F5)
                const fullPool = this.getRangePool(scale, "Bb3", "F5");

                let bars = [];


                // 12-Bar Blues Chords (Simplified)
                const progression = [
                    "I7", "I7", "I7", "I7",
                    "IV7", "IV7", "I7", "I7",
                    "V7", "IV7", "I7", "V7"
                ];

                if (style === 'jazz') {
                    // Jazz Blues: Bar 8=VI7, Bar 9=IIm7, Bar 10=V7
                    progression[7] = "VI7"; // Turnaround start
                    progression[8] = "IIm7";
                    progression[9] = "V7";
                }

                // --- NEW GENERATION LOGIC (Strict) ---
                let savedMotif = null; // Pattern of durations

                for (let i = 1; i <= 12; i++) {
                    const barIndex = i - 1;
                    const chordFunc = progression[barIndex];
                    const chordName = this.getChordName(key, chordFunc);

                    let barNotes = [];
                    let rhythmPattern = [];

                    // --- RHYTHM SELECTION ---

                    // Bar 1: Motif (Level Pool)
                    if (i === 1) {
                        const pool = this.getRhythmPool(difficulty, style);
                        rhythmPattern = pool[Math.floor(Math.random() * pool.length)];
                        savedMotif = [...rhythmPattern]; // Copy
                    }
                    // Bar 2: Rest/Space
                    else if (i === 2) {
                        if (style === 'trad') rhythmPattern = ['1r'];
                        else rhythmPattern = ['2r', '4n', '4n']; // Jazz filler
                    }
                    // Bar 3: Response (Reuse Motif)
                    else if (i === 3) {
                        rhythmPattern = savedMotif || ['1n'];
                    }
                    // Bar 4: Tension (Level Pool)
                    else if (i === 4) {
                        const pool = this.getRhythmPool(difficulty, style);
                        rhythmPattern = pool[Math.floor(Math.random() * pool.length)];
                    }
                    // Bar 5: Change to IV (New Pattern)
                    else if (i === 5) {
                        const pool = this.getRhythmPool(difficulty, style);
                        // Ensure different from Motif if possible, but random is fine
                        rhythmPattern = pool[Math.floor(Math.random() * pool.length)];
                    }
                    // Bar 6: Air (Level - 1 or Simple)
                    else if (i === 6) {
                        const lowLevel = Math.max(1, difficulty - 1);
                        const pool = this.getRhythmPool(lowLevel, style);
                        rhythmPattern = pool[Math.floor(Math.random() * pool.length)];
                    }
                    // Bar 7: Descending (Level Pool)
                    else if (i === 7) {
                        const pool = this.getRhythmPool(difficulty, style);
                        rhythmPattern = pool[Math.floor(Math.random() * pool.length)];
                    }
                    // Bar 8: Prep (Rest/Fill)
                    else if (i === 8) {
                        if (style === 'trad') rhythmPattern = ['2r', '2n'];
                        else rhythmPattern = ['4n', '8n', '8n', '4n', '4n']; // Build up
                    }
                    // Bar 9 & 10: Climax (Level + 1)
                    else if (i === 9 || i === 10) {
                        const highLevel = Math.min(5, difficulty + 1);
                        const pool = this.getRhythmPool(highLevel, style);
                        rhythmPattern = pool[Math.floor(Math.random() * pool.length)];
                    }
                    // Bar 11: Resolution (Level Pool)
                    else if (i === 11) {
                        const pool = this.getRhythmPool(difficulty, style);
                        rhythmPattern = pool[Math.floor(Math.random() * pool.length)];
                    }
                    // Bar 12: Turnaround (Specific)
                    else if (i === 12) {
                        rhythmPattern = ['4n', '4n', '4n', '4n']; // Stomp ending
                    }

                    // --- NOTE ASSIGNMENT ---

                    // We have the rhythm (durations), now assign pitches
                    barNotes = this.fillRhythmWithNotes(rhythmPattern, fullPool, key, i, chordName);

                    bars.push({
                        id: i,
                        chord: chordName,
                        notes: barNotes
                    });
                }
                // (End Loop)

                return bars;
            }

            fillRhythmWithNotes(rhythmPattern, pool, key, barNum, chordName) {
                // Return array of {pitch, duration}
                return rhythmPattern.map((dur, index) => {
                    let pitch = "B4"; // Default
                    if (dur.includes("r")) {
                        // Rest
                        return { pitch: "B4", duration: dur };
                    } else {
                        // Note
                        pitch = this.getRandom(pool);

                        // --- SPECIFIC PITCH RULES ---

                        // Bar 1 & 11: First note = Tonic
                        if ((barNum === 1 || barNum === 11) && index === 0) {
                            pitch = this.getClosestNote(pool, key + "4");
                        }

                        // Bar 5: First note = Target IV
                        if (barNum === 5 && index === 0) {
                            const iv = Tonal.Note.transpose(key, "P4");
                            pitch = this.getClosestNote(pool, iv + "4");
                        }

                        // Bar 12: Last note = Dominant (V)
                        if (barNum === 12 && index === rhythmPattern.length - 1) {
                            const v = Tonal.Note.transpose(key, "P5");
                            pitch = this.getClosestNote(pool, v + "4");
                        }

                        // Bar 9/10 (Climax): Use High Range if possible
                        if (barNum === 9 || barNum === 10) {
                            // Try to nudge up
                            if (Tonal.Note.midi(pitch) < Tonal.Note.midi(key + "5")) {
                                // Simple octave shift if in pool? or just random high
                            }
                        }

                        return { pitch, duration: dur };
                    }
                });
            }

            // --- RHYTHM POOLS ---
            getRhythmPool(level, style) {
                // Return array of duration patterns (Arrays of strings)
                // e.g. ['2n', '4n', '4n']

                // LEVEL 1: Zen
                if (level === 1) {
                    return [
                        ['1n'], ['2n', '2n'], ['2n', '2r'], ['1r']
                    ];
                }

                // LEVEL 2: Ground (No syncopation)
                if (level === 2) {
                    return [
                        ['2n', '4n', '4n'],
                        ['4n', '4n', '2n'],
                        ['4n', '4n', '4n', '4n'],
                        ['2n', '2n']
                    ];
                }

                // LEVEL 3: Groove (8ths + Syncopation)
                if (level === 3) {
                    return [
                        ['4n', '8n', '8n', '2n'],
                        ['4n.', '8n', '2n'], // Syncopation
                        ['2n', '4n', '4n'],
                        ['8n', '8n', '4n', '2n']
                    ];
                }

                // LEVEL 4: Agile
                if (level === 4) {
                    if (style === 'jazz') {
                        // Swing Lines (Continuous 8ths)
                        return [
                            ['8n', '8n', '8n', '8n', '4n', '4n'],
                            ['4r', '8n', '8n', '8n', '8n', '4n'],
                            ['8n', '8n', '8n', '8n', '8n', '8n', '4n']
                        ];
                    } else {
                        // Trad: Triplets (8t)
                        // Note: Renderer must handle "8t, 8t, 8t" as (n n n)/8
                        return [
                            ['8t', '8t', '8t', '2n.',], // Triplet start
                            ['2n', '8t', '8t', '8t', '4n'],
                            ['4n', '4n', '8t', '8t', '8t', '4n']
                        ];
                    }
                }

                // LEVEL 5: Master (16th, Fast Flow)
                // Keep simpler for now to avoid VexFlow 16th complex beaming if not robust
                // Let's use dense 8th/Triplet mix
                return [
                    ['16n', '16n', '16n', '16n', '4n', '2n'],
                    ['8n', '8n', '16n', '16n', '16n', '16n', '4n'],
                    ['8t', '8t', '8t', '8t', '8t', '8t', '2n']
                ];
            }

            // --- HELPERS ---

            getRangePool(scaleNotes, min, max) {
                let pool = [];
                const minH = Tonal.Note.midi(min);
                const maxH = Tonal.Note.midi(max);

                for (let o = 3; o <= 6; o++) {
                    scaleNotes.forEach(n => {
                        const note = n + o;
                        const h = Tonal.Note.midi(note);
                        if (h >= minH && h <= maxH) pool.push(note);
                    });
                }
                return pool;
            }

            getChordName(key, func) {
                // func: "I7", "IIm7", "IV7", "V7"
                // Extract Degree and Quality
                let degree = "";
                let quality = "";

                if (func.startsWith("IV")) { degree = "IV"; quality = func.substring(2); }
                else if (func.startsWith("II")) { degree = "II"; quality = func.substring(2); }
                else if (func.startsWith("VI")) { degree = "VI"; quality = func.substring(2); } // VI7
                else if (func.startsWith("V")) { degree = "V"; quality = func.substring(1); }
                else if (func.startsWith("I")) { degree = "I"; quality = func.substring(1); }

                let interval = "1P";
                if (degree === "II") interval = "2M";
                if (degree === "VI") interval = "6M";
                if (degree === "IV") interval = "4P";
                if (degree === "V") interval = "5P";

                const root = Tonal.Note.transpose(key, interval);
                return root + quality;
            }

            genMotif(pool, difficulty) {
                // Simple 1-bar pattern: 2 quarters, 1 half?
                return [
                    { pitch: this.getRandom(pool), duration: "4" },
                    { pitch: this.getRandom(pool), duration: "4" },
                    { pitch: this.getRandom(pool), duration: "2" }
                ];
            }

            applyRhythm(pool, durations) {
                return durations.map(d => ({
                    pitch: this.getRandom(pool),
                    duration: d
                }));
            }

            genRandomNotes(pool, count, duration) {
                let res = [];
                for (let i = 0; i < count; i++) res.push({ pitch: this.getRandom(pool), duration: duration });
                return res;
            }

            genLine(pool, count, dir) { // available only quarters for now
                let startIdx = Math.floor(Math.random() * (pool.length - count));
                if (dir === 'desc') startIdx += count;
                // clamp
                if (startIdx >= pool.length) startIdx = pool.length - 1;

                let res = [];
                for (let i = 0; i < count; i++) {
                    let idx = dir === 'desc' ? startIdx - i : startIdx + i;
                    if (idx < 0) idx = 0; if (idx >= pool.length) idx = pool.length - 1;
                    res.push({ pitch: pool[idx], duration: "4" });
                }
                return res;
            }

            getRandom(arr) {
                return arr[Math.floor(Math.random() * arr.length)];
            }

            getClosestNote(pool, target) {
                // Simple check
                return pool.reduce((prev, curr) => {
                    return Math.abs(Tonal.Note.midi(curr) - Tonal.Note.midi(target)) < Math.abs(Tonal.Note.midi(prev) - Tonal.Note.midi(target)) ? curr : prev;
                });
            }

            getNeighbor(pool, pitch) {
                const idx = pool.indexOf(pitch);
                if (idx > 0) return pool[idx - 1];
                return pool[idx + 1] || pitch;
            }

            getDurFromDiff(diff) {
                // 1=w, 2=h, 3=q, 4=8, 5=8+trip
                if (diff == 1) return "1";
                if (diff == 2) return "2";
                if (diff >= 3) return "4";
                return "4";
            }
        }

        // --- RENDERER ---

        class ScoreRenderer {
            constructor() {
                this.div = document.getElementById('notation-output');
                this.vfFactory = new VF.Factory({
                    renderer: { elementId: 'notation-output', width: CANVAS_WIDTH, height: CANVAS_HEIGHT }
                });
                this.context = this.vfFactory.getContext();
            }

            render(bars) {
                this.context.clear();
                // Bars 1-12
                this.context.clear();
                // Bars 1-12
                // Row 1: 0-3
                // Row 2: 4-7
                // Row 3: 8-11

                this.drawSystem(bars.slice(0, 4), 0, 0);
                this.drawSystem(bars.slice(4, 8), 0, ROW_HEIGHT);
                this.drawSystem(bars.slice(8, 12), 0, ROW_HEIGHT * 2);
            }

            drawSystem(barsData, x, y) {
                // Total Width = 1200. Bar Width ~ 285
                let currentX = x + 10; // Reduced Margin
                const widthPerBar = (CANVAS_WIDTH - 40) / 4;

                barsData.forEach((bar, i) => {
                    const measure = this.vfFactory.Stave({ x: currentX, y: y, width: widthPerBar });

                    // Add Clef/Time/Key only on first Bar of System (i==0)
                    if (i === 0) {
                        measure.addClef("treble").addTimeSignature("4/4");
                        // Add Key Sig? Maybe later.
                    }

                    // Chord Symbol
                    // DISPLAY CONCERT CHORD (Requested by User)
                    let displayChord = bar.chord; // Written Chord (e.g. D7)

                    try {
                        // Transpose Written -> Concert
                        // If Written D, Instr Bb -> Concert C (-2M)
                        // This uses getConcertPitch logic but on Chord Root
                        const root = Tonal.Chord.get(bar.chord).tonic;
                        if (root) {
                            const concertRoot = getConcertPitch(root + "4").replace(/\d/g, ""); // strip octave
                            const quality = bar.chord.replace(root, "");
                            displayChord = concertRoot + quality;
                        }
                    } catch (e) { console.warn("Chord Transpose Error", e); }

                    measure.setText(displayChord, VF.Modifier.Position.ABOVE, { shift_y: 0, justification: VF.TextNote.Justification.LEFT });
                    measure.setContext(this.context).draw();

                    // Logic to store visual bounds for cursor
                    bar.visualX = currentX;
                    bar.visualY = y;
                    bar.visualWidth = widthPerBar;

                    // --- STAVENOTE & TUPLET LOGIC ---
                    const notes = [];
                    const beams = [];
                    const tuplets = [];
                    let tripletBuffer = [];

                    bar.notes.forEach(n => {
                        let dur = n.duration;
                        const isRest = dur.includes("r");
                        const cleanDur = dur.replace("r", "").replace("n", ""); // "4", "8", "8t"

                        let vfDur = cleanDur;
                        let isDotted = false;

                        // Parse Duration
                        if (dur.includes(".")) {
                            isDotted = true;
                            vfDur = cleanDur.replace(".", ""); // "4"
                        }

                        // Tuplet Handling (8t)
                        if (cleanDur === "8t") {
                            vfDur = "8"; // Treat as 8th for StaveNote
                        } else if (vfDur === "1") vfDur = "w";
                        else if (vfDur === "2") vfDur = "h";
                        else if (vfDur === "4") vfDur = "q";
                        else if (vfDur === "8") vfDur = "8";
                        else if (vfDur === "16") vfDur = "16";

                        // Append 'd' for dotted (Native VexFlow)
                        if (isDotted) {
                            vfDur += "d";
                        }

                        if (isRest) vfDur += "r";

                        // Pitch logic
                        // Normalize pitch to lowercase for VexFlow (e.g. "C#4" -> "c#/4")
                        const noteKey = n.pitch.toLowerCase().replace(/(\d+)/, "/$1");

                        const staveNote = new VF.StaveNote({
                            keys: isRest ? ["b/4"] : [noteKey],
                            duration: vfDur,
                            auto_stem: true
                        });

                        // Dotted handled by 'd' in duration for TICKS.
                        // But must explicitly add visual Dot for DRAWING in VexFlow 4.
                        if (isDotted) {
                            try {
                                staveNote.addDot(0);
                            } catch (e) {
                                console.warn("Visual Dot Error:", e);
                            }
                        }

                        // Accidental Logic
                        if (!isRest) {
                            // Check if pitch has accidental literally in the string (e.g. "#", "b")
                            // Do not rely solely on match if Tonal simplified it?
                            // But my generator outputs "Eb4", "D4". Tonal.simplify ensures it.
                            const acc = n.pitch.match(/[#b]+/); // removed pipe | which detects literal pipe
                            if (acc) {
                                const accType = acc[0]; // "#" or "b" or "bb" etc.
                                // Basic validation
                                if (['#', '##', 'b', 'bb', 'n'].includes(accType)) {
                                    try {
                                        const accidental = new VF.Accidental(accType);
                                        staveNote.addModifier(accidental, 0);
                                    } catch (e) {
                                        console.error("Error adding Accidental " + accType + ":", e);
                                    }
                                }
                            }
                        }

                        // Collection
                        if (cleanDur === "8t") {
                            tripletBuffer.push(staveNote);
                            notes.push(staveNote); // Add to main list too
                            if (tripletBuffer.length === 3) {
                                // Create Tuplet
                                const tuplet = new VF.Tuplet(tripletBuffer);
                                tuplets.push(tuplet);
                                // Create Beam for Triplet?
                                beams.push(new VF.Beam(tripletBuffer));
                                tripletBuffer = [];
                            }
                        } else {
                            notes.push(staveNote);
                            // Auto-beam consecutive 8ths/16ths if we wanted, but let's keep it simple.
                        }
                    });

                    // Flush buffer if incomplete (shouldn't happen with strict logic)
                    if (tripletBuffer.length > 0) {
                        console.warn("Incomplete Tuplet found in Bar " + i);
                    }

                    // Create Voice
                    const voice = this.vfFactory.Voice().setStrict(false).addTickables(notes);

                    // Apply Tuplets to Voice (Not needed for Voice itself, but for drawing)

                    // Format
                    const justifyWidth = (i === 0) ? widthPerBar - 50 : widthPerBar - 10;
                    try {
                        new VF.Formatter().joinVoices([voice]).format([voice], justifyWidth);

                        // Draw (Only if formatted)
                        voice.draw(this.context, measure);

                        // Draw Tuplets & Beams
                        tuplets.forEach(t => t.setContext(this.context).draw());
                        beams.forEach(b => b.setContext(this.context).draw());
                    } catch (e) {
                        console.error("VexFlow Error Bar " + i, e);
                        // Optional: alert only if critical? Or keep user informed.
                        // alert("VF Error Bar " + i + ": " + e.message); 
                        // Suppress alert to avoid flooding if it works partially
                    }

                    currentX += widthPerBar;
                });
            }
        }

        // --- TRANSPOSITION HELPER ---
        function getConcertPitch(writtenNote) {
            const instr = Settings.getTransposition(); // 'C', 'Bb', 'Eb'
            // Eb Alto: Sounds Major 6th lower (-6M) (or up m3 then down 8v)
            if (instr === 'Eb') return Tonal.Note.transpose(writtenNote, "-6M");
            // Bb Tenor/Sop: Sounds Major 2nd lower (-2M) (Tenor is -9M, but usually -2M works for playback range)
            if (instr === 'Bb') return Tonal.Note.transpose(writtenNote, "-2M");
            return writtenNote;
        }

        // --- MAIN APP ---
        const generator = new BluesGenerator();
        const renderer = new ScoreRenderer();
        let synth = new Tone.PolySynth(Tone.Synth).toDestination();

        // UI Handlers
        document.getElementById('gen-btn').onclick = () => {
            console.log("Generate Button Clicked");
            try {
                const concertKey = document.getElementById('key-select').value;
                const style = document.getElementById('style-select').value;
                const diff = parseInt(document.getElementById('diff-slider').value);

                // --- Calculate WRITTEN KEY for Generator ---
                // If Concert=C, Sax=Bb -> Written=D (+2M)
                // If Concert=C, Sax=Eb -> Written=A (+6M)

                const instr = Settings.getTransposition();
                let writtenKey = concertKey;
                if (instr === 'Bb') writtenKey = Tonal.Note.transpose(concertKey, "2M");
                if (instr === 'Eb') writtenKey = Tonal.Note.transpose(concertKey, "6M");

                // Cleanup accidental (e.g. D# -> Eb if preferred? Tonal handles it)
                // Just ensure simple names
                writtenKey = Tonal.Note.simplify(writtenKey);

                console.log("Params:", { concertKey, writtenKey, instr, style, diff });

                if (typeof Tonal === 'undefined') throw new Error("Tonal library not loaded");

                generatedScore = generator.generate(writtenKey, style, diff);
                console.log("Score Generated:", generatedScore);

                renderer.render(generatedScore);
                console.log("Render Complete");

                // Reset UI
                isPlaying = false;
                Tone.Transport.stop();
            } catch (e) {
                console.error("GENERATION ERROR:", e);
                alert("Error: " + e.message);
            }
        };

        document.getElementById('diff-slider').oninput = (e) => {
            document.getElementById('diff-val').innerText = e.target.value;
        };

        // --- PLAYBACK ENGINE ---
        document.getElementById('play-btn').onclick = () => togglePlayback();

        async function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        function stopPlayback() {
            isPlaying = false;
            Tone.Transport.stop();
            Tone.Transport.cancel();
            document.getElementById('play-btn').innerText = "‚ñ∂ REPRODUCIR";
            document.getElementById('play-btn').classList.remove("active");
            document.getElementById('cursor-line').style.display = 'none';
        }

        async function startPlayback() {
            if (generatedScore.length === 0) return alert("Genera primero!");

            await Tone.start();
            isPlaying = true;
            document.getElementById('play-btn').innerText = "‚èπ PARAR";
            document.getElementById('play-btn').classList.add("active");
            document.getElementById('cursor-line').style.display = 'block';

            schedulePlayback();
            startMetronome();
            Tone.Transport.start();
        }

        function schedulePlayback() {
            Tone.Transport.stop();
            Tone.Transport.cancel();

            const bpm = document.getElementById('bpm-input').value;
            Tone.Transport.bpm.value = bpm;

            let currentTime = 0;

            // Count-In (4 Beats)
            const countInBeats = 4;
            const countInDuration = (60 / bpm) * countInBeats;
            currentTime = countInDuration;

            // Loop through all 12 bars
            generatedScore.forEach((bar, i) => {
                // Bar Visuals
                Tone.Transport.schedule((time) => {
                    updateCursor(bar.visualX, bar.visualY, bar.visualWidth);
                }, currentTime);

                // Bar Audio
                bar.notes.forEach(note => {
                    const dur = note.duration.replace("r", "");
                    const isRest = note.duration.includes("r");

                    // Fix Duration String for Tone.js
                    // If "8t", use "8t". If "4", use "4n".
                    let toneDur = dur;
                    if (!dur.includes("t") && !dur.includes("n")) toneDur += "n";

                    const timeVal = Tone.Time(toneDur).toSeconds();

                    if (!isRest) {
                        const concertPitch = getConcertPitch(note.pitch);
                        Tone.Transport.schedule((time) => {
                            synth.triggerAttackRelease(concertPitch, toneDur, time);
                        }, currentTime);
                    }

                    currentTime += timeVal; // Increment
                });
            });

            // End Event - LOOPING ENABLED
            // No manual stop. Native Loop will handle it.
            Tone.Transport.loop = true;
            Tone.Transport.loopStart = countInDuration; // Skip count-in on loop
            Tone.Transport.loopEnd = currentTime; // Should match 12 bars exactly
        }

        // --- METRONOME ---
        function startMetronome() {
            if (metroVol) metroVol.dispose();
            metroVol = new Tone.Volume(-12).toDestination();

            // Metronome Loop
            new Tone.Loop(time => {
                const btn = document.getElementById('metro-btn');
                if (btn && btn.innerText.includes("ON")) {
                    // Click on Beat
                    // new Tone.MembraneSynth().toDestination().triggerAttackRelease("C2", "32n", time, 0.5); 
                    // Simple Oscillator click like Lectura
                    // Simple Oscillator click like Lectura
                    // Reduced volume (-12dB)
                    new Tone.Oscillator(1000, "triangle").connect(metroVol).start(time).stop(time + 0.05);
                }
            }, "4n").start(0);
        }

        document.getElementById('metro-btn').onclick = (e) => {
            const btn = e.target;
            if (btn.innerText.includes("OFF")) {
                btn.innerText = "Metronomo ON";
                btn.classList.add("active");
            } else {
                btn.innerText = "Metronomo OFF";
                btn.classList.remove("active");
            }
        };

        // Cursor Animation (Native CSS Transition)
        function updateCursor(x, y, width) {
            const el = document.getElementById('cursor-line');
            if (el.style.display === 'none') el.style.display = 'block';

            // Reset position instantly
            el.style.transition = 'none';
            el.style.top = (y + 20) + "px"; // Offset for Stave
            el.style.left = x + "px";
            el.style.height = "80px"; // Stave height

            // Force Reflow
            el.getBoundingClientRect();

            // Then Animate across width
            requestAnimationFrame(() => {
                const bpm = document.getElementById('bpm-input').value;
                const barDuration = (60 / bpm) * 4;
                el.style.transition = `transform ${barDuration}s linear`;
                el.style.transform = `translateX(${width}px)`;
            });

            // Reset Transform at start of function
            el.style.transform = "translateX(0px)";
        }

        // --- INIT ---
        // Generate once on load
        setTimeout(() => document.getElementById('gen-btn').click(), 500);

    </script>
</body>

</html>